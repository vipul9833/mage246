{
  "version": 3,
  "sources": ["../src/scheduler.js", "../src/reactivity.js", "../src/mutation.js", "../src/scope.js", "../src/interceptor.js", "../src/magics.js", "../src/utils/error.js", "../src/evaluator.js", "../src/directives.js", "../src/utils/dispatch.js", "../src/nextTick.js", "../src/utils/walk.js", "../src/utils/warn.js", "../src/lifecycle.js", "../src/utils/classes.js", "../src/utils/styles.js", "../src/utils/once.js", "../src/directives/x-transition.js", "../src/clone.js", "../src/utils/bind.js", "../src/utils/debounce.js", "../src/utils/throttle.js", "../src/plugin.js", "../src/store.js", "../src/binds.js", "../src/datas.js", "../src/alpine.js", "../../../node_modules/@vue/shared/dist/shared.esm-bundler.js", "../../../node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js", "../src/magics/$nextTick.js", "../src/magics/$dispatch.js", "../src/magics/$watch.js", "../src/magics/$store.js", "../src/magics/$data.js", "../src/magics/$root.js", "../src/magics/$refs.js", "../src/ids.js", "../src/magics/$id.js", "../src/magics/$el.js", "../src/magics/index.js", "../src/directives/x-modelable.js", "../src/directives/x-teleport.js", "../src/directives/x-ignore.js", "../src/directives/x-effect.js", "../src/utils/on.js", "../src/directives/x-model.js", "../src/directives/x-cloak.js", "../src/directives/x-init.js", "../src/directives/x-text.js", "../src/directives/x-html.js", "../src/directives/x-bind.js", "../src/directives/x-data.js", "../src/directives/x-show.js", "../src/directives/x-for.js", "../src/directives/x-ref.js", "../src/directives/x-if.js", "../src/directives/x-id.js", "../src/directives/x-on.js", "../src/directives/index.js", "../src/index.js", "../builds/cdn.js"],
  "sourcesContent": ["\nlet flushPending = false\nlet flushing = false\nlet queue = []\n\nexport function scheduler (callback) { queueJob(callback) }\n\nfunction queueJob(job) {\n    if (! queue.includes(job)) queue.push(job)\n\n    queueFlush()\n}\nexport function dequeueJob(job) {\n    let index = queue.indexOf(job)\n\n    if (index !== -1) queue.splice(index, 1)\n}\n\nfunction queueFlush() {\n    if (! flushing && ! flushPending) {\n        flushPending = true\n\n        queueMicrotask(flushJobs)\n    }\n}\n\nexport function flushJobs() {\n    flushPending = false\n    flushing = true\n\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]()\n    }\n\n    queue.length = 0\n\n    flushing = false\n}\n", "\nimport { scheduler } from './scheduler'\n\nlet reactive, effect, release, raw\n\nlet shouldSchedule = true\nexport function disableEffectScheduling(callback) {\n    shouldSchedule = false\n\n    callback()\n\n    shouldSchedule = true\n}\n\nexport function setReactivityEngine(engine) {\n    reactive = engine.reactive\n    release = engine.release\n    effect = (callback) => engine.effect(callback, { scheduler: task => {\n        if (shouldSchedule) {\n            scheduler(task)\n        } else {\n            task()\n        }\n    } })\n    raw = engine.raw\n}\n\nexport function overrideEffect(override) { effect = override }\n\nexport function elementBoundEffect(el) {\n    let cleanup = () => {}\n\n    let wrappedEffect = (callback) => {\n        let effectReference = effect(callback)\n\n        if (! el._x_effects) {\n            el._x_effects = new Set\n\n            // Livewire depends on el._x_runEffects.\n            el._x_runEffects = () => { el._x_effects.forEach(i => i()) }\n        }\n\n        el._x_effects.add(effectReference)\n\n        cleanup = () => {\n            if (effectReference === undefined) return\n\n            el._x_effects.delete(effectReference)\n\n            release(effectReference)\n        }\n\n        return effectReference\n    }\n\n    return [wrappedEffect, () => { cleanup() }]\n}\n\nexport {\n    release,\n    reactive,\n    effect,\n    raw,\n}\n", "let onAttributeAddeds = []\nlet onElRemoveds = []\nlet onElAddeds = []\n\nexport function onElAdded(callback) {\n    onElAddeds.push(callback)\n}\n\nexport function onElRemoved(el, callback) {\n    if (typeof callback === 'function') {\n        if (! el._x_cleanups) el._x_cleanups = []\n        el._x_cleanups.push(callback)\n    } else {\n        callback = el\n        onElRemoveds.push(callback)\n    }\n}\n\nexport function onAttributesAdded(callback) {\n    onAttributeAddeds.push(callback)\n}\n\nexport function onAttributeRemoved(el, name, callback) {\n    if (! el._x_attributeCleanups) el._x_attributeCleanups = {}\n    if (! el._x_attributeCleanups[name]) el._x_attributeCleanups[name] = []\n\n    el._x_attributeCleanups[name].push(callback)\n}\n\nexport function cleanupAttributes(el, names) {\n    if (! el._x_attributeCleanups) return\n\n    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n        if (names === undefined || names.includes(name)) {\n            value.forEach(i => i())\n\n            delete el._x_attributeCleanups[name]\n        }\n    })\n}\n\nlet observer = new MutationObserver(onMutate)\n\nlet currentlyObserving = false\n\nexport function startObservingMutations() {\n    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true })\n\n    currentlyObserving = true\n}\n\nexport function stopObservingMutations() {\n    flushObserver()\n\n    observer.disconnect()\n\n    currentlyObserving = false\n}\n\nlet recordQueue = []\nlet willProcessRecordQueue = false\n\nexport function flushObserver() {\n    recordQueue = recordQueue.concat(observer.takeRecords())\n\n    if (recordQueue.length && ! willProcessRecordQueue) {\n        willProcessRecordQueue = true\n\n        queueMicrotask(() => {\n            processRecordQueue()\n\n            willProcessRecordQueue = false\n        })\n    }\n}\n\nfunction processRecordQueue() {\n     onMutate(recordQueue)\n\n     recordQueue.length = 0\n}\n\nexport function mutateDom(callback) {\n    if (! currentlyObserving) return callback()\n\n    stopObservingMutations()\n\n    let result = callback()\n\n    startObservingMutations()\n\n    return result\n}\n\nlet isCollecting = false\nlet deferredMutations = []\n\nexport function deferMutations() {\n    isCollecting = true\n}\n\nexport function flushAndStopDeferringMutations() {\n    isCollecting = false\n\n    onMutate(deferredMutations)\n\n    deferredMutations = []\n}\n\nfunction onMutate(mutations) {\n    if (isCollecting) {\n        deferredMutations = deferredMutations.concat(mutations)\n\n        return\n    }\n\n    let addedNodes = []\n    let removedNodes = []\n    let addedAttributes = new Map\n    let removedAttributes = new Map\n\n    for (let i = 0; i < mutations.length; i++) {\n        if (mutations[i].target._x_ignoreMutationObserver) continue\n\n        if (mutations[i].type === 'childList') {\n            mutations[i].addedNodes.forEach(node => node.nodeType === 1 && addedNodes.push(node))\n            mutations[i].removedNodes.forEach(node => node.nodeType === 1 && removedNodes.push(node))\n        }\n\n        if (mutations[i].type === 'attributes') {\n            let el = mutations[i].target\n            let name = mutations[i].attributeName\n            let oldValue = mutations[i].oldValue\n\n            let add = () => {\n                if (! addedAttributes.has(el)) addedAttributes.set(el, [])\n\n                addedAttributes.get(el).push({ name,  value: el.getAttribute(name) })\n            }\n\n            let remove = () => {\n                if (! removedAttributes.has(el)) removedAttributes.set(el, [])\n\n                removedAttributes.get(el).push(name)\n            }\n\n            // New attribute.\n            if (el.hasAttribute(name) && oldValue === null) {\n                add()\n            // Changed atttribute.\n            } else if (el.hasAttribute(name)) {\n                remove()\n                add()\n            // Removed atttribute.\n            } else {\n                remove()\n            }\n        }\n    }\n\n    removedAttributes.forEach((attrs, el) => {\n        cleanupAttributes(el, attrs)\n    })\n\n    addedAttributes.forEach((attrs, el) => {\n        onAttributeAddeds.forEach(i => i(el, attrs))\n    })\n\n    for (let node of removedNodes) {\n        // If an element gets moved on a page, it's registered\n        // as both an \"add\" and \"remove\", so we want to skip those.\n        if (addedNodes.includes(node)) continue\n\n        onElRemoveds.forEach(i => i(node))\n        \n        if (node._x_cleanups) {\n            while (node._x_cleanups.length) node._x_cleanups.pop()()\n        }\n    }\n\n    // Mutations are bundled together by the browser but sometimes\n    // for complex cases, there may be javascript code adding a wrapper\n    // and then an alpine component as a child of that wrapper in the same\n    // function and the mutation observer will receive 2 different mutations.\n    // when it comes time to run them, the dom contains both changes so the child\n    // element would be processed twice as Alpine calls initTree on\n    // both mutations. We mark all nodes as _x_ignored and only remove the flag\n    // when processing the node to avoid those duplicates.\n    addedNodes.forEach((node) => {\n        node._x_ignoreSelf = true\n        node._x_ignore = true\n    })\n    for (let node of addedNodes) {\n        // If an element gets moved on a page, it's registered\n        // as both an \"add\" and \"remove\", so we want to skip those.\n        if (removedNodes.includes(node)) continue\n\n        // If the node was eventually removed as part of one of his\n        // parent mutations, skip it\n        if (! node.isConnected) continue\n\n        delete node._x_ignoreSelf\n        delete node._x_ignore\n        onElAddeds.forEach(i => i(node))\n        node._x_ignore = true\n        node._x_ignoreSelf = true\n    }\n    addedNodes.forEach((node) => {\n        delete node._x_ignoreSelf\n        delete node._x_ignore\n    })\n\n    addedNodes = null\n    removedNodes = null\n    addedAttributes = null\n    removedAttributes = null\n}\n", "\nexport function scope(node) {\n    return mergeProxies(closestDataStack(node))\n}\n\nexport function addScopeToNode(node, data, referenceNode) {\n    node._x_dataStack = [data, ...closestDataStack(referenceNode || node)]\n\n    return () => {\n        node._x_dataStack = node._x_dataStack.filter(i => i !== data)\n    }\n}\n\nexport function hasScope(node) {\n    return !! node._x_dataStack\n}\n\nexport function refreshScope(element, scope) {\n    let existingScope = element._x_dataStack[0]\n\n    Object.entries(scope).forEach(([key, value]) => {\n        existingScope[key] = value\n    })\n}\n\nexport function closestDataStack(node) {\n    if (node._x_dataStack) return node._x_dataStack\n\n    if (typeof ShadowRoot === 'function' && node instanceof ShadowRoot) {\n        return closestDataStack(node.host)\n    }\n\n    if (! node.parentNode) {\n        return []\n    }\n\n    return closestDataStack(node.parentNode)\n}\n\nexport function closestDataProxy(el) {\n    return mergeProxies(closestDataStack(el))\n}\n\nexport function mergeProxies(objects) {\n    let thisProxy = new Proxy({}, {\n        ownKeys: () => {\n            return Array.from(new Set(objects.flatMap(i => Object.keys(i))))\n        },\n\n        has: (target, name) => {\n            return objects.some(obj => obj.hasOwnProperty(name))\n        },\n\n        get: (target, name) => {\n            return (objects.find(obj => {\n                if (obj.hasOwnProperty(name)) {\n                    let descriptor = Object.getOwnPropertyDescriptor(obj, name)\n\n                    // If we already bound this getter, don't rebind.\n                    if ((descriptor.get && descriptor.get._x_alreadyBound) || (descriptor.set && descriptor.set._x_alreadyBound)) {\n                        return true\n                    }\n                    \n                    // Properly bind getters and setters to this wrapper Proxy.\n                    if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\n                        // Only bind user-defined getters, not our magic properties.\n                        let getter = descriptor.get\n                        let setter = descriptor.set\n                        let property = descriptor\n\n                        getter = getter && getter.bind(thisProxy)\n                        setter = setter && setter.bind(thisProxy)\n\n                        if (getter) getter._x_alreadyBound = true\n                        if (setter) setter._x_alreadyBound = true\n\n                        Object.defineProperty(obj, name, {\n                            ...property,\n                            get: getter,\n                            set: setter,\n                        })\n                    }\n\n                    return true \n                }\n\n                return false\n            }) || {})[name]\n        },\n\n        set: (target, name, value) => {\n            let closestObjectWithKey = objects.find(obj => obj.hasOwnProperty(name))\n\n            if (closestObjectWithKey) {\n                closestObjectWithKey[name] = value\n            } else {\n                objects[objects.length - 1][name] = value\n            }\n\n            return true\n        },\n    })\n\n    return thisProxy\n}\n", "// Warning: The concept of \"interceptors\" in Alpine is not public API and is subject to change\n// without tagging a major release.\n\nexport function initInterceptors(data) {\n    let isObject = val => typeof val === 'object' && !Array.isArray(val) && val !== null\n\n    let recurse = (obj, basePath = '') => {\n        Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\n            // Skip getters.\n            if (enumerable === false || value === undefined) return\n\n            let path = basePath === '' ? key : `${basePath}.${key}`\n\n            if (typeof value === 'object' && value !== null && value._x_interceptor) {\n                obj[key] = value.initialize(data, path, key)\n            } else {\n                if (isObject(value) && value !== obj && ! (value instanceof Element)) {\n                    recurse(value, path)\n                }\n            }\n        })\n    }\n\n    return recurse(data)\n}\n\nexport function interceptor(callback, mutateObj = () => {}) {\n    let obj = {\n        initialValue: undefined,\n\n        _x_interceptor: true,\n\n        initialize(data, path, key) {\n            return callback(this.initialValue, () => get(data, path), (value) => set(data, path, value), path, key)\n        }\n    }\n\n    mutateObj(obj)\n\n    return initialValue => {\n        if (typeof initialValue === 'object' && initialValue !== null && initialValue._x_interceptor) {\n            // Support nesting interceptors.\n            let initialize = obj.initialize.bind(obj)\n\n            obj.initialize = (data, path, key) => {\n                let innerValue = initialValue.initialize(data, path, key)\n\n                obj.initialValue = innerValue\n\n                return initialize(data, path, key)\n            }\n        } else {\n            obj.initialValue = initialValue\n        }\n\n        return obj\n    }\n}\n\nfunction get(obj, path) {\n    return path.split('.').reduce((carry, segment) => carry[segment], obj)\n}\n\nfunction set(obj, path, value) {\n    if (typeof path === 'string') path = path.split('.')\n\n    if (path.length === 1) obj[path[0]] = value;\n       else if (path.length === 0) throw error;\n    else {\n       if (obj[path[0]])\n          return set(obj[path[0]], path.slice(1), value);\n       else {\n          obj[path[0]] = {};\n          return set(obj[path[0]], path.slice(1), value);\n       }\n    }\n}\n", "import Alpine from './alpine'\nimport { getElementBoundUtilities } from './directives'\nimport { interceptor } from './interceptor'\nimport { onElRemoved } from './mutation'\n\nlet magics = {}\n\nexport function magic(name, callback) {\n    magics[name] = callback\n}\n\nexport function injectMagics(obj, el) {\n    Object.entries(magics).forEach(([name, callback]) => {\n        Object.defineProperty(obj, `$${name}`, {\n            get() {\n                let [utilities, cleanup] = getElementBoundUtilities(el)\n                \n                utilities = {interceptor, ...utilities}\n                \n                onElRemoved(el, cleanup)\n\n                return callback(el, utilities)\n            },\n\n            enumerable: false,\n        })\n    })\n\n    return obj\n}\n", "export function tryCatch(el, expression, callback, ...args) {\n    try {\n        return callback(...args)\n    } catch (e) {\n        handleError( e, el, expression )\n    }\n}\n\nexport function handleError(error, el, expression = undefined) {\n    Object.assign( error, { el, expression } )\n\n    console.warn(`Alpine Expression Error: ${error.message}\\n\\n${ expression ? 'Expression: \\\"' + expression + '\\\"\\n\\n' : '' }`, el)\n\n    setTimeout( () => { throw error }, 0 )\n}\n", "import { closestDataStack, mergeProxies } from './scope'\nimport { injectMagics } from './magics'\nimport { tryCatch, handleError } from './utils/error'\n\nlet shouldAutoEvaluateFunctions = true\n\nexport function dontAutoEvaluateFunctions(callback) {\n    let cache = shouldAutoEvaluateFunctions\n\n    shouldAutoEvaluateFunctions = false\n\n    callback()\n\n    shouldAutoEvaluateFunctions = cache\n}\n\nexport function evaluate(el, expression, extras = {}) {\n    let result\n\n    evaluateLater(el, expression)(value => result = value, extras)\n\n    return result\n}\n\nexport function evaluateLater(...args) {\n    return theEvaluatorFunction(...args)\n}\n\nlet theEvaluatorFunction = normalEvaluator\n\nexport function setEvaluator(newEvaluator) {\n    theEvaluatorFunction = newEvaluator\n}\n\nexport function normalEvaluator(el, expression) {\n    let overriddenMagics = {}\n\n    injectMagics(overriddenMagics, el)\n\n    let dataStack = [overriddenMagics, ...closestDataStack(el)]\n\n    if (typeof expression === 'function') {\n        return generateEvaluatorFromFunction(dataStack, expression)\n    }\n\n    let evaluator = generateEvaluatorFromString(dataStack, expression, el)\n\n    return tryCatch.bind(null, el, expression, evaluator)\n}\n\nexport function generateEvaluatorFromFunction(dataStack, func) {\n    return (receiver = () => {}, { scope = {}, params = [] } = {}) => {\n        let result = func.apply(mergeProxies([scope, ...dataStack]), params)\n\n        runIfTypeOfFunction(receiver, result)\n    }\n}\n\nlet evaluatorMemo = {}\n\nfunction generateFunctionFromString(expression, el) {\n    if (evaluatorMemo[expression]) {\n        return evaluatorMemo[expression]\n    }\n\n    let AsyncFunction = Object.getPrototypeOf(async function(){}).constructor\n\n    // Some expressions that are useful in Alpine are not valid as the right side of an expression.\n    // Here we'll detect if the expression isn't valid for an assignement and wrap it in a self-\n    // calling function so that we don't throw an error AND a \"return\" statement can b e used.\n    let rightSideSafeExpression = 0\n        // Support expressions starting with \"if\" statements like: \"if (...) doSomething()\"\n        || /^[\\n\\s]*if.*\\(.*\\)/.test(expression)\n        // Support expressions starting with \"let/const\" like: \"let foo = 'bar'\"\n        || /^(let|const)\\s/.test(expression)\n            ? `(() => { ${expression} })()`\n            : expression\n\n    const safeAsyncFunction = () => {\n        try {\n            return new AsyncFunction(['__self', 'scope'], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`)\n        } catch ( error ) {\n            handleError( error, el, expression )\n            return Promise.resolve()\n        }\n    }\n    let func = safeAsyncFunction()\n\n    evaluatorMemo[expression] = func\n\n    return func\n}\n\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n    let func = generateFunctionFromString(expression, el)\n\n    return (receiver = () => {}, { scope = {}, params = [] } = {}) => {\n        func.result = undefined\n        func.finished = false\n\n        // Run the function.\n\n        let completeScope = mergeProxies([ scope, ...dataStack ])\n\n        if (typeof func === 'function' ) {\n            let promise = func(func, completeScope).catch((error) => handleError(error, el, expression))\n\n            // Check if the function ran synchronously,\n            if (func.finished) {\n                // Return the immediate result.\n                runIfTypeOfFunction(receiver, func.result, completeScope, params, el)\n                // Once the function has run, we clear func.result so we don't create\n                // memory leaks. func is stored in the evaluatorMemo and every time\n                // it runs, it assigns the evaluated expression to result which could\n                // potentially store a reference to the DOM element that will be removed later on.\n                func.result = undefined\n            } else {\n                // If not, return the result when the promise resolves.\n                promise.then(result => {\n                    runIfTypeOfFunction(receiver, result, completeScope, params, el)\n                }).catch( error => handleError( error, el, expression ) )\n                .finally( () => func.result = undefined )\n            }\n        }\n    }\n}\n\nexport function runIfTypeOfFunction(receiver, value, scope, params, el) {\n    if (shouldAutoEvaluateFunctions && typeof value === 'function') {\n        let result = value.apply(scope, params)\n\n        if (result instanceof Promise) {\n            result.then(i => runIfTypeOfFunction(receiver, i, scope, params)).catch( error => handleError( error, el, value ) )\n        } else {\n            receiver(result)\n        }\n    } else {\n        receiver(value)\n    }\n}\n", "import { onAttributeRemoved, onElRemoved } from './mutation'\nimport { evaluate, evaluateLater } from './evaluator'\nimport { elementBoundEffect } from './reactivity'\nimport Alpine from './alpine'\n\nlet prefixAsString = 'x-'\n\nexport function prefix(subject = '') {\n    return prefixAsString + subject\n}\n\nexport function setPrefix(newPrefix) {\n    prefixAsString = newPrefix\n}\n\nlet directiveHandlers = {}\n\nexport function directive(name, callback) {\n    directiveHandlers[name] = callback\n}\n\nexport function directives(el, attributes, originalAttributeOverride) {\n    attributes = Array.from(attributes)\n\n    if (el._x_virtualDirectives) {\n        let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }))\n\n        let staticAttributes = attributesOnly(vAttributes)\n\n        // Handle binding normal HTML attributes (non-Alpine directives).\n        vAttributes = vAttributes.map(attribute => {\n            if (staticAttributes.find(attr => attr.name === attribute.name)) {\n                return {\n                    name: `x-bind:${attribute.name}`,\n                    value: `\"${attribute.value}\"`,\n                }\n            }\n\n            return attribute\n        })\n\n        attributes = attributes.concat(vAttributes)\n    }\n\n    let transformedAttributeMap = {}\n\n    let directives = attributes\n        .map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName))\n        .filter(outNonAlpineAttributes)\n        .map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride))\n        .sort(byPriority)\n\n    return directives.map(directive => {\n        return getDirectiveHandler(el, directive)\n    })\n}\n\nexport function attributesOnly(attributes) {\n    return Array.from(attributes)\n        .map(toTransformedAttributes())\n        .filter(attr => ! outNonAlpineAttributes(attr))\n}\n\nlet isDeferringHandlers = false\nlet directiveHandlerStacks = new Map\nlet currentHandlerStackKey = Symbol()\n\nexport function deferHandlingDirectives(callback) {\n    isDeferringHandlers = true\n\n    let key = Symbol()\n\n    currentHandlerStackKey = key\n\n    directiveHandlerStacks.set(key, [])\n\n    let flushHandlers = () => {\n        while (directiveHandlerStacks.get(key).length) directiveHandlerStacks.get(key).shift()()\n\n        directiveHandlerStacks.delete(key)\n    }\n\n    let stopDeferring = () => { isDeferringHandlers = false; flushHandlers() }\n\n    callback(flushHandlers)\n\n    stopDeferring()\n}\n\nexport function getElementBoundUtilities(el) {\n    let cleanups = []\n\n    let cleanup = callback => cleanups.push(callback)\n\n    let [effect, cleanupEffect] = elementBoundEffect(el)\n\n    cleanups.push(cleanupEffect)\n\n    let utilities = {\n        Alpine,\n        effect,\n        cleanup,\n        evaluateLater: evaluateLater.bind(evaluateLater, el),\n        evaluate: evaluate.bind(evaluate, el),\n    }\n\n    let doCleanup = () => cleanups.forEach(i => i())\n\n    return [utilities, doCleanup]\n}\n\nexport function getDirectiveHandler(el, directive) {\n    let noop = () => {}\n\n    let handler = directiveHandlers[directive.type] || noop\n\n    let [utilities, cleanup] = getElementBoundUtilities(el)\n\n    onAttributeRemoved(el, directive.original, cleanup)\n\n    let fullHandler = () => {\n        if (el._x_ignore || el._x_ignoreSelf) return\n\n        handler.inline && handler.inline(el, directive, utilities)\n\n        handler = handler.bind(handler, el, directive, utilities)\n\n        isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler) : handler()\n    }\n\n    fullHandler.runCleanups = cleanup\n\n    return fullHandler\n}\n\nexport let startingWith = (subject, replacement) => ({ name, value }) => {\n    if (name.startsWith(subject)) name = name.replace(subject, replacement)\n\n    return { name, value }\n}\n\nexport let into = i => i\n\nfunction toTransformedAttributes(callback = () => {}) {\n    return ({ name, value }) => {\n        let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\n            return transform(carry)\n        }, { name, value })\n\n        if (newName !== name) callback(newName, name)\n\n        return { name: newName, value: newValue }\n    }\n}\n\nlet attributeTransformers = []\n\nexport function mapAttributes(callback) {\n    attributeTransformers.push(callback)\n}\n\nfunction outNonAlpineAttributes({ name }) {\n    return alpineAttributeRegex().test(name)\n}\n\nlet alpineAttributeRegex = () => (new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`))\n\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n    return ({ name, value }) => {\n        let typeMatch = name.match(alpineAttributeRegex())\n        let valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/)\n        let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || []\n        let original = originalAttributeOverride || transformedAttributeMap[name] || name\n\n        return {\n            type: typeMatch ? typeMatch[1] : null,\n            value: valueMatch ? valueMatch[1] : null,\n            modifiers: modifiers.map(i => i.replace('.', '')),\n            expression: value,\n            original,\n        }\n    }\n}\n\nconst DEFAULT = 'DEFAULT'\n\nlet directiveOrder = [\n    'ignore',\n    'ref',\n    'data',\n    'id',\n    // @todo: provide better directive ordering mechanisms so\n    // that I don't have to manually add things like \"tabs\"\n    // to the order list...\n    'tabs',\n    'radio',\n    'switch',\n    'disclosure',\n    'bind',\n    'init',\n    'for',\n    'mask',\n    'model',\n    'modelable',\n    'transition',\n    'show',\n    'if',\n    DEFAULT,\n    'teleport',\n]\n\nfunction byPriority(a, b) {\n    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type\n    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type\n\n    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB)\n}\n", "\nexport function dispatch(el, name, detail = {}) {\n    el.dispatchEvent(\n        new CustomEvent(name, {\n            detail,\n            bubbles: true,\n            // Allows events to pass the shadow DOM barrier.\n            composed: true,\n            cancelable: true,\n        })\n    )\n}\n", "\nlet tickStack = []\n\nlet isHolding = false\n\nexport function nextTick(callback = () => {}) {\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks()\n    })\n  })\n\n  return new Promise((res) => {\n    tickStack.push(() => {\n        callback();\n        res();\n    });\n  })\n}\n\nexport function releaseNextTicks() {\n    isHolding = false\n\n    while (tickStack.length) tickStack.shift()()\n}\n\nexport function holdNextTicks() {\n    isHolding = true\n}\n", "export function walk(el, callback) {\n    if (typeof ShadowRoot === 'function' && el instanceof ShadowRoot) {\n        Array.from(el.children).forEach(el => walk(el, callback))\n\n        return\n    }\n\n    let skip = false\n\n    callback(el, () => skip = true)\n\n    if (skip) return\n\n    let node = el.firstElementChild\n\n    while (node) {\n        walk(node, callback, false)\n\n        node = node.nextElementSibling\n    }\n}\n// export function walk(el, callback) {\n//     if (el instanceof ShadowRoot || el instanceof DocumentFragment) {\n//         Array.from(el.children).forEach(el => walk(el, callback))\n\n//         return\n//     }\n\n//     callback(el, () => {\n//         let node = el.firstElementChild\n\n//         while (node) {\n//             walk(node, callback)\n\n//             node = node.nextElementSibling\n//         }\n//     })\n// }\n", "\nexport function warn(message, ...args) {\n    console.warn(`Alpine Warning: ${message}`, ...args)\n}\n", "import { startObservingMutations, onAttributesAdded, onElAdded, onElRemoved, cleanupAttributes } from \"./mutation\"\nimport { deferHandlingDirectives, directives } from \"./directives\"\nimport { dispatch } from './utils/dispatch'\nimport { nextTick } from \"./nextTick\"\nimport { walk } from \"./utils/walk\"\nimport { warn } from './utils/warn'\n\nexport function start() {\n    if (! document.body) warn('Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine\\'s `<script>` tag?')\n\n    dispatch(document, 'alpine:init')\n    dispatch(document, 'alpine:initializing')\n\n    startObservingMutations()\n\n    onElAdded(el => initTree(el, walk))\n    onElRemoved(el => destroyTree(el))\n\n    onAttributesAdded((el, attrs) => {\n        directives(el, attrs).forEach(handle => handle())\n    })\n\n    let outNestedComponents = el => ! closestRoot(el.parentElement, true)\n    Array.from(document.querySelectorAll(allSelectors()))\n        .filter(outNestedComponents)\n        .forEach(el => {\n            initTree(el)\n        })\n\n    dispatch(document, 'alpine:initialized')\n}\n\nlet rootSelectorCallbacks = []\nlet initSelectorCallbacks = []\n\nexport function rootSelectors() {\n    return rootSelectorCallbacks.map(fn => fn())\n}\n\nexport function allSelectors() {\n    return rootSelectorCallbacks.concat(initSelectorCallbacks).map(fn => fn())\n}\n\nexport function addRootSelector(selectorCallback) { rootSelectorCallbacks.push(selectorCallback) }\nexport function addInitSelector(selectorCallback) { initSelectorCallbacks.push(selectorCallback) }\n\nexport function closestRoot(el, includeInitSelectors = false) {\n    return findClosest(el, element => {\n        const selectors = includeInitSelectors ? allSelectors() : rootSelectors()\n\n        if (selectors.some(selector => element.matches(selector))) return true\n    })\n}\n\nexport function findClosest(el, callback) {\n    if (! el) return\n\n    if (callback(el)) return el\n\n    // Support crawling up teleports.\n    if (el._x_teleportBack) el = el._x_teleportBack\n\n    if (! el.parentElement) return\n\n    return findClosest(el.parentElement, callback)\n}\n\nexport function isRoot(el) {\n    return rootSelectors().some(selector => el.matches(selector))\n}\n\nexport function initTree(el, walker = walk) {\n    deferHandlingDirectives(() => {\n        walker(el, (el, skip) => {\n            directives(el, el.attributes).forEach(handle => handle())\n\n            el._x_ignore && skip()\n        })\n    })\n}\n\nfunction destroyTree(root) {\n    walk(root, el => cleanupAttributes(el))\n}\n", "\nexport function setClasses(el, value) {\n    if (Array.isArray(value)) {\n        return setClassesFromString(el, value.join(' '))\n    } else if (typeof value === 'object' && value !== null) {\n        return setClassesFromObject(el, value)\n    } else if (typeof value === 'function') {\n        return setClasses(el, value())\n    }\n\n    return setClassesFromString(el, value)\n}\n\nfunction setClassesFromString(el, classString) {\n    let split = classString => classString.split(' ').filter(Boolean)\n\n    let missingClasses = classString => classString.split(' ').filter(i => ! el.classList.contains(i)).filter(Boolean)\n\n    let addClassesAndReturnUndo = classes => {\n        el.classList.add(...classes)\n\n        return () => { el.classList.remove(...classes) }\n    }\n\n    // This is to allow short-circuit expressions like: :class=\"show || 'hidden'\" && \"show && 'block'\"\n    classString = (classString === true) ? classString = '' : (classString || '')\n\n    return addClassesAndReturnUndo(missingClasses(classString))\n}\n\nfunction setClassesFromObject(el, classObject) {\n    let split = classString => classString.split(' ').filter(Boolean)\n\n    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean)\n    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => ! bool ? split(classString) : false).filter(Boolean)\n\n    let added = []\n    let removed = []\n\n    forRemove.forEach(i => {\n        if (el.classList.contains(i)) {\n            el.classList.remove(i)\n            removed.push(i)\n        }\n    })\n\n    forAdd.forEach(i => {\n        if (! el.classList.contains(i)) {\n            el.classList.add(i)\n            added.push(i)\n        }\n    })\n\n    return () => {\n        removed.forEach(i => el.classList.add(i))\n        added.forEach(i => el.classList.remove(i))\n    }\n}\n", "\nexport function setStyles(el, value) {\n    if (typeof value === 'object' && value !== null) {\n        return setStylesFromObject(el, value)\n    }\n\n    return setStylesFromString(el, value)\n}\n\nfunction setStylesFromObject(el, value) {\n    let previousStyles = {}\n\n    Object.entries(value).forEach(([key, value]) => {\n        previousStyles[key] = el.style[key]\n\n        // When we use javascript object, css properties use the camelCase\n        // syntax but when we use setProperty, we need the css format\n        // so we need to convert camelCase to kebab-case.\n        // In case key is a CSS variable, leave it as it is.\n        if (! key.startsWith('--')) {\n            key = kebabCase(key);\n        }\n\n        el.style.setProperty(key, value)\n    })\n\n    setTimeout(() => {\n        if (el.style.length === 0) {\n            el.removeAttribute('style')\n        }\n    })\n\n    return () => {\n        setStyles(el, previousStyles)\n    }\n}\n\nfunction setStylesFromString(el, value) {\n    let cache = el.getAttribute('style', value)\n\n    el.setAttribute('style', value)\n\n    return () => {\n        el.setAttribute('style', cache || '')\n    }\n}\n\nfunction kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase()\n}\n", "\nexport function once(callback, fallback = () => {}) {\n    let called = false\n\n    return function () {\n        if (! called) {\n            called = true\n\n            callback.apply(this, arguments)\n        } else {\n            fallback.apply(this, arguments)\n        }\n    }\n}\n", "import { releaseNextTicks, holdNextTicks } from '../nextTick'\nimport { setClasses } from '../utils/classes'\nimport { setStyles } from '../utils/styles'\nimport { directive } from '../directives'\nimport { mutateDom } from '../mutation'\nimport { once } from '../utils/once'\n\ndirective('transition', (el, { value, modifiers, expression }, { evaluate }) => {\n    if (typeof expression === 'function') expression = evaluate(expression)\n\n    if (! expression) {\n        registerTransitionsFromHelper(el, modifiers, value)\n    } else {\n        registerTransitionsFromClassString(el, expression, value)\n    }\n})\n\nfunction registerTransitionsFromClassString(el, classString, stage) {\n    registerTransitionObject(el, setClasses, '')\n\n    let directiveStorageMap = {\n        'enter': (classes) => { el._x_transition.enter.during = classes },\n        'enter-start': (classes) => { el._x_transition.enter.start = classes },\n        'enter-end': (classes) => { el._x_transition.enter.end = classes },\n        'leave': (classes) => { el._x_transition.leave.during = classes },\n        'leave-start': (classes) => { el._x_transition.leave.start = classes },\n        'leave-end': (classes) => { el._x_transition.leave.end = classes },\n    }\n\n    directiveStorageMap[stage](classString)\n}\n\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n    registerTransitionObject(el, setStyles)\n\n    let doesntSpecify = (! modifiers.includes('in') && ! modifiers.includes('out')) && ! stage\n    let transitioningIn = doesntSpecify || modifiers.includes('in') || ['enter'].includes(stage)\n    let transitioningOut = doesntSpecify || modifiers.includes('out') || ['leave'].includes(stage)\n\n    if (modifiers.includes('in') && ! doesntSpecify) {\n        modifiers = modifiers.filter((i, index) => index < modifiers.indexOf('out'))\n    }\n\n    if (modifiers.includes('out') && ! doesntSpecify) {\n        modifiers = modifiers.filter((i, index) => index > modifiers.indexOf('out'))\n    }\n\n    let wantsAll = ! modifiers.includes('opacity') && ! modifiers.includes('scale')\n    let wantsOpacity = wantsAll || modifiers.includes('opacity')\n    let wantsScale = wantsAll || modifiers.includes('scale')\n    let opacityValue = wantsOpacity ? 0 : 1\n    let scaleValue = wantsScale ? modifierValue(modifiers, 'scale', 95) / 100 : 1\n    let delay = modifierValue(modifiers, 'delay', 0)\n    let origin = modifierValue(modifiers, 'origin', 'center')\n    let property = 'opacity, transform'\n    let durationIn = modifierValue(modifiers, 'duration', 150) / 1000\n    let durationOut = modifierValue(modifiers, 'duration', 75) / 1000\n    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`\n\n    if (transitioningIn) {\n        el._x_transition.enter.during = {\n            transformOrigin: origin,\n            transitionDelay: delay,\n            transitionProperty: property,\n            transitionDuration: `${durationIn}s`,\n            transitionTimingFunction: easing,\n        }\n\n        el._x_transition.enter.start = {\n            opacity: opacityValue,\n            transform: `scale(${scaleValue})`,\n        }\n\n        el._x_transition.enter.end = {\n            opacity: 1,\n            transform: `scale(1)`,\n        }\n    }\n\n    if (transitioningOut) {\n        el._x_transition.leave.during = {\n            transformOrigin: origin,\n            transitionDelay: delay,\n            transitionProperty: property,\n            transitionDuration: `${durationOut}s`,\n            transitionTimingFunction: easing,\n        }\n\n        el._x_transition.leave.start = {\n            opacity: 1,\n            transform: `scale(1)`,\n        }\n\n        el._x_transition.leave.end = {\n            opacity: opacityValue,\n            transform: `scale(${scaleValue})`,\n        }\n    }\n}\n\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n    if (! el._x_transition) el._x_transition = {\n        enter: { during: defaultValue, start: defaultValue, end: defaultValue },\n\n        leave: { during: defaultValue, start: defaultValue, end: defaultValue },\n\n        in(before = () => {}, after = () => {}) {\n            transition(el, setFunction, {\n                during: this.enter.during,\n                start: this.enter.start,\n                end: this.enter.end,\n            }, before, after)\n        },\n\n        out(before = () => {}, after = () => {}) {\n            transition(el, setFunction, {\n                during: this.leave.during,\n                start: this.leave.start,\n                end: this.leave.end,\n            }, before, after)\n        },\n    }\n}\n\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function (el, value, show, hide) {\n    // We are running this function after one tick to prevent\n    // a race condition from happening where elements that have a\n    // @click.away always view themselves as shown on the page.\n    // If the tab is active, we prioritise requestAnimationFrame which plays\n    // nicely with nested animations otherwise we use setTimeout to make sure\n    // it keeps running in background. setTimeout has a lower priority in the\n    // event loop so it would skip nested transitions but when the tab is\n    // hidden, it's not relevant.\n    const nextTick = document.visibilityState === 'visible' ? requestAnimationFrame : setTimeout;\n    let clickAwayCompatibleShow = () => nextTick(show);\n\n    if (value) {\n        if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n            // This fixes a bug where if you are only transitioning OUT and you are also using @click.outside\n            // the element when shown immediately starts transitioning out. There is a test in the manual\n            // transition test file for this: /tests/cypress/manual-transition-test.html\n            (el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length))\n                ? el._x_transition.in(show)\n                : clickAwayCompatibleShow()\n        } else {\n            el._x_transition\n                ? el._x_transition.in(show)\n                : clickAwayCompatibleShow()\n        }\n\n        return\n    }\n\n    // Livewire depends on el._x_hidePromise.\n    el._x_hidePromise = el._x_transition\n        ? new Promise((resolve, reject) => {\n            el._x_transition.out(() => {}, () => resolve(hide))\n\n            el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }))\n        })\n        : Promise.resolve(hide)\n\n    queueMicrotask(() => {\n        let closest = closestHide(el)\n\n        if (closest) {\n            if (! closest._x_hideChildren) closest._x_hideChildren = []\n\n            closest._x_hideChildren.push(el)\n        } else {\n            nextTick(() => {\n                let hideAfterChildren = el => {\n                    let carry = Promise.all([\n                        el._x_hidePromise,\n                        ...(el._x_hideChildren || []).map(hideAfterChildren),\n                    ]).then(([i]) => i())\n\n                    delete el._x_hidePromise\n                    delete el._x_hideChildren\n\n                    return carry\n                }\n\n                hideAfterChildren(el).catch((e) => {\n                    if (! e.isFromCancelledTransition) throw e\n                })\n            })\n        }\n    })\n}\n\nfunction closestHide(el) {\n    let parent = el.parentNode\n\n    if (! parent) return\n\n    return parent._x_hidePromise ? parent : closestHide(parent)\n}\n\nexport function transition(el, setFunction, { during, start, end } = {}, before = () => {}, after = () => {}) {\n    if (el._x_transitioning) el._x_transitioning.cancel()\n\n    if (Object.keys(during).length === 0 && Object.keys(start).length === 0 && Object.keys(end).length === 0) {\n        // Execute right away if there is no transition.\n        before(); after()\n        return\n    }\n\n    let undoStart, undoDuring, undoEnd\n\n    performTransition(el, {\n        start() {\n            undoStart = setFunction(el, start)\n        },\n        during() {\n            undoDuring = setFunction(el, during)\n        },\n        before,\n        end() {\n            undoStart()\n\n            undoEnd = setFunction(el, end)\n        },\n        after,\n        cleanup() {\n            undoDuring()\n            undoEnd()\n        },\n    })\n}\n\nexport function performTransition(el, stages) {\n    // All transitions need to be truly \"cancellable\". Meaning we need to\n    // account for interruptions at ALL stages of the transitions and\n    // immediately run the rest of the transition.\n    let interrupted, reachedBefore, reachedEnd\n\n    let finish = once(() => {\n        mutateDom(() => {\n            interrupted = true\n\n            if (! reachedBefore) stages.before()\n\n            if (! reachedEnd) {\n                stages.end()\n\n                releaseNextTicks()\n            }\n\n            stages.after()\n\n            // Adding an \"isConnected\" check, in case the callback removed the element from the DOM.\n            if (el.isConnected) stages.cleanup()\n\n            delete el._x_transitioning\n        })\n    })\n\n    el._x_transitioning = {\n        beforeCancels: [],\n        beforeCancel(callback) { this.beforeCancels.push(callback) },\n        cancel: once(function () { while (this.beforeCancels.length) { this.beforeCancels.shift()() }; finish(); }),\n        finish,\n    }\n\n    mutateDom(() => {\n        stages.start()\n        stages.during()\n    })\n\n    holdNextTicks()\n\n    requestAnimationFrame(() => {\n        if (interrupted) return\n\n        // Note: Safari's transitionDuration property will list out comma separated transition durations\n        // for every single transition property. Let's grab the first one and call it a day.\n        let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n        let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, '').replace('s', '')) * 1000\n\n        if (duration === 0) duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000\n\n        mutateDom(() => {\n            stages.before()\n        })\n\n        reachedBefore = true\n\n        requestAnimationFrame(() => {\n            if (interrupted) return\n\n            mutateDom(() => {\n                stages.end()\n            })\n\n            releaseNextTicks()\n\n            setTimeout(el._x_transitioning.finish, duration + delay)\n\n            reachedEnd = true\n        })\n    })\n}\n\nexport function modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback\n\n    // If it IS present, grab the value after it: x-show.transition.duration.500ms\n    const rawValue = modifiers[modifiers.indexOf(key) + 1]\n\n    if (! rawValue) return fallback\n\n    if (key === 'scale') {\n        // Check if the very next value is NOT a number and return the fallback.\n        // If x-show.transition.scale, we'll use the default scale value.\n        // That is how a user opts out of the opacity transition.\n        if (isNaN(rawValue)) return fallback\n    }\n\n    if (key === 'duration') {\n        // Support x-transition.duration.500ms && duration.500\n        let match = rawValue.match(/([0-9]+)ms/)\n        if (match) return match[1]\n    }\n\n    if (key === 'origin') {\n        // Support chaining origin directions: x-show.transition.top.right\n        if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n            return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ')\n        }\n    }\n\n    return rawValue\n}\n", "import { effect, release, overrideEffect } from \"./reactivity\"\nimport { initTree, isRoot } from \"./lifecycle\"\nimport { walk } from \"./utils/walk\"\n\nlet isCloning = false\n\nexport function skipDuringClone(callback, fallback = () => {}) {\n    return (...args) => isCloning ? fallback(...args) : callback(...args)\n}\n\nexport function onlyDuringClone(callback) {\n    return (...args) => isCloning && callback(...args)\n}\n\nexport function interuptCrawl(callback) {\n    return (...args) => isCloning || callback(...args)\n}\n\nexport function clone(oldEl, newEl) {\n    if (! newEl._x_dataStack) newEl._x_dataStack = oldEl._x_dataStack\n\n    isCloning = true\n\n    dontRegisterReactiveSideEffects(() => {\n        cloneTree(newEl)\n    })\n\n    isCloning = false\n}\n\nexport function cloneTree(el) {\n    let hasRunThroughFirstEl = false\n\n    let shallowWalker = (el, callback) => {\n        walk(el, (el, skip) => {\n            if (hasRunThroughFirstEl && isRoot(el)) return skip()\n\n            hasRunThroughFirstEl = true\n\n            callback(el, skip)\n        })\n    }\n\n    initTree(el, shallowWalker)\n}\n\nfunction dontRegisterReactiveSideEffects(callback) {\n    let cache = effect\n\n    overrideEffect((callback, el) => {\n        let storedEffect = cache(callback)\n\n        release(storedEffect)\n\n        return () => {}\n    })\n\n    callback()\n\n    overrideEffect(cache)\n}\n", "import { reactive } from '../reactivity'\nimport { setClasses } from './classes'\nimport { setStyles } from './styles'\n\nexport default function bind(el, name, value, modifiers = []) {\n    // Register bound data as pure observable data for other APIs to use.\n    if (! el._x_bindings) el._x_bindings = reactive({})\n\n    el._x_bindings[name] = value\n\n    name = modifiers.includes('camel') ? camelCase(name) : name\n\n    switch (name) {\n        case 'value':\n            bindInputValue(el, value)\n            break;\n\n        case 'style':\n            bindStyles(el, value)\n            break;\n\n        case 'class':\n            bindClasses(el, value)\n            break;\n\n        default:\n            bindAttribute(el, name, value)\n            break;\n    }\n}\n\nfunction bindInputValue(el, value) {\n    if (el.type === 'radio') {\n        // Set radio value from x-bind:value, if no \"value\" attribute exists.\n        // If there are any initial state values, radio will have a correct\n        // \"checked\" value since x-bind:value is processed before x-model.\n        if (el.attributes.value === undefined) {\n            el.value = value\n        }\n\n        // @todo: yuck\n        if (window.fromModel) {\n            el.checked = checkedAttrLooseCompare(el.value, value)\n        }\n    } else if (el.type === 'checkbox') {\n        // If we are explicitly binding a string to the :value, set the string,\n        // If the value is a boolean/array/number/null/undefined, leave it alone, it will be set to \"on\"\n        // automatically.\n        if (Number.isInteger(value)) {\n            el.value = value\n        } else if (! Number.isInteger(value) && ! Array.isArray(value) && typeof value !== 'boolean' && ! [null, undefined].includes(value)) {\n            el.value = String(value)\n        } else {\n            if (Array.isArray(value)) {\n                el.checked = value.some(val => checkedAttrLooseCompare(val, el.value))\n            } else {\n                el.checked = !!value\n            }\n        }\n    } else if (el.tagName === 'SELECT') {\n        updateSelect(el, value)\n    } else {\n        if (el.value === value) return\n\n        el.value = value\n    }\n}\n\nfunction bindClasses(el, value) {\n    if (el._x_undoAddedClasses) el._x_undoAddedClasses()\n\n    el._x_undoAddedClasses = setClasses(el, value)\n}\n\nfunction bindStyles(el, value) {\n    if (el._x_undoAddedStyles) el._x_undoAddedStyles()\n\n    el._x_undoAddedStyles = setStyles(el, value)\n}\n\nfunction bindAttribute(el, name, value) {\n    if ([null, undefined, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n        el.removeAttribute(name)\n    } else {\n        if (isBooleanAttr(name)) value = name\n\n        setIfChanged(el, name, value)\n    }\n}\n\nfunction setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n        el.setAttribute(attrName, value)\n    }\n}\n\nfunction updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => { return value + '' })\n\n    Array.from(el.options).forEach(option => {\n        option.selected = arrayWrappedValue.includes(option.value)\n    })\n}\n\nfunction camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase())\n}\n\nfunction checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB\n}\n\nfunction isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = [\n        'disabled','checked','required','readonly','hidden','open', 'selected',\n        'autofocus', 'itemscope', 'multiple', 'novalidate','allowfullscreen',\n        'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop',\n        'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer',\n        'nomodule'\n    ]\n\n    return booleanAttributes.includes(attrName)\n}\n\nfunction attributeShouldntBePreservedIfFalsy(name) {\n    return ! ['aria-pressed', 'aria-checked', 'aria-expanded', 'aria-selected'].includes(name)\n}\n\nexport function getBinding(el, name, fallback) {\n    // First let's get it out of Alpine bound data.\n    if (el._x_bindings && el._x_bindings[name] !== undefined) return el._x_bindings[name]\n\n    // If not, we'll return the literal attribute.\n    let attr = el.getAttribute(name)\n\n    // Nothing bound:\n    if (attr === null) return typeof fallback === 'function' ? fallback() : fallback\n\n    // The case of a custom attribute with no value. Ex: <div manual>\n    if (attr === '') return true\n\n    if (isBooleanAttr(name)) {\n        return !! [name, 'true'].includes(attr)\n    }\n\n    return attr\n}\n", "\nexport function debounce(func, wait) {\n    var timeout\n\n    return function() {\n        var context = this, args = arguments\n\n        var later = function () {\n            timeout = null\n\n            func.apply(context, args)\n        }\n\n        clearTimeout(timeout)\n\n        timeout = setTimeout(later, wait)\n    }\n}\n", "\nexport function throttle(func, limit) {\n    let inThrottle\n\n    return function() {\n        let context = this, args = arguments\n\n        if (! inThrottle) {\n            func.apply(context, args)\n\n            inThrottle = true\n\n            setTimeout(() => inThrottle = false, limit)\n        }\n    }\n}\n", "import Alpine from './alpine'\n\nexport function plugin(callback) {\n    callback(Alpine)\n}\n", "import { initInterceptors } from \"./interceptor\";\nimport { reactive } from \"./reactivity\"\n\nlet stores = {}\nlet isReactive = false\n\nexport function store(name, value) {\n    if (! isReactive) { stores = reactive(stores); isReactive = true; }\n\n    if (value === undefined) {\n        return stores[name]\n    }\n\n    stores[name] = value\n\n    if (typeof value === 'object' && value !== null && value.hasOwnProperty('init') && typeof value.init === 'function') {\n        stores[name].init()\n    }\n\n    initInterceptors(stores[name])\n}\n\nexport function getStores() { return stores }\n", "import { attributesOnly, directives } from \"./directives\"\n\nlet binds = {}\n\nexport function bind(name, bindings) {\n    let getBindings = typeof bindings !== 'function' ? () => bindings : bindings\n\n    if (name instanceof Element) {\n        applyBindingsObject(name, getBindings())\n    } else {\n        binds[name] = getBindings\n    }\n}\n\nexport function injectBindingProviders(obj) {\n    Object.entries(binds).forEach(([name, callback]) => {\n        Object.defineProperty(obj, name, {\n            get() {\n                return (...args) => {\n                    return callback(...args)\n                }\n            }\n        })\n    })\n\n    return obj\n}\n\nexport function addVirtualBindings(el, bindings) {\n    let getBindings = typeof bindings !== 'function' ? () => bindings : bindings\n\n    el._x_virtualDirectives = getBindings()\n}\n\nexport function applyBindingsObject(el, obj, original) {\n    let cleanupRunners = []\n\n    while (cleanupRunners.length) cleanupRunners.pop()()\n\n    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }))\n\n    let staticAttributes = attributesOnly(attributes)\n\n    // Handle binding normal HTML attributes (non-Alpine directives).\n    attributes = attributes.map(attribute => {\n        if (staticAttributes.find(attr => attr.name === attribute.name)) {\n            return {\n                name: `x-bind:${attribute.name}`,\n                value: `\"${attribute.value}\"`,\n            }\n        }\n\n        return attribute\n    })\n\n    directives(el, attributes, original).map(handle => {\n        cleanupRunners.push(handle.runCleanups)\n\n        handle()\n    })\n}\n", "\nlet datas = {}\n\nexport function data(name, callback) {\n    datas[name] = callback\n}\n\nexport function injectDataProviders(obj, context) {\n    Object.entries(datas).forEach(([name, callback]) => {\n        Object.defineProperty(obj, name, {\n            get() {\n                return (...args) => {\n                    return callback.bind(context)(...args)\n                }\n            },\n\n            enumerable: false,\n        })\n    })\n\n    return obj\n}\n", "import { setReactivityEngine, disableEffectScheduling, reactive, effect, release, raw } from './reactivity'\nimport { mapAttributes, directive, setPrefix as prefix, prefix as prefixed } from './directives'\nimport { start, addRootSelector, addInitSelector, closestRoot, findClosest, initTree } from './lifecycle'\nimport { mutateDom, deferMutations, flushAndStopDeferringMutations } from './mutation'\nimport { mergeProxies, closestDataStack, addScopeToNode, scope as $data } from './scope'\nimport { setEvaluator, evaluate, evaluateLater, dontAutoEvaluateFunctions } from './evaluator'\nimport { transition } from './directives/x-transition'\nimport { clone, skipDuringClone } from './clone'\nimport { interceptor } from './interceptor'\nimport { getBinding as bound } from './utils/bind'\nimport { debounce } from './utils/debounce'\nimport { throttle } from './utils/throttle'\nimport { setStyles } from './utils/styles'\nimport { nextTick } from './nextTick'\nimport { plugin } from './plugin'\nimport { magic } from './magics'\nimport { store } from './store'\nimport { bind } from './binds'\nimport { data } from './datas'\n\nlet Alpine = {\n    get reactive() { return reactive },\n    get release() { return release },\n    get effect() { return effect },\n    get raw() { return raw },\n    version: ALPINE_VERSION,\n    flushAndStopDeferringMutations,\n    dontAutoEvaluateFunctions,\n    disableEffectScheduling,\n    setReactivityEngine,\n    closestDataStack,\n    skipDuringClone,\n    addRootSelector,\n    addInitSelector,\n    addScopeToNode,\n    deferMutations,\n    mapAttributes,\n    evaluateLater,\n    setEvaluator,\n    mergeProxies,\n    findClosest,\n    closestRoot,\n    interceptor, // INTERNAL: not public API and is subject to change without major release.\n    transition, // INTERNAL\n    setStyles, // INTERNAL\n    mutateDom,\n    directive,\n    throttle,\n    debounce,\n    evaluate,\n    initTree,\n    nextTick,\n    prefixed,\n    prefix,\n    plugin,\n    magic,\n    store,\n    start,\n    clone,\n    bound,\n    $data,\n    data,\n    bind,\n}\n\nexport default Alpine\n", "/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, babelParserDefaultPlugins, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, invokeArrayFns, isArray, isBooleanAttr, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownAttr, isMap, isModelListener, isNoUnitNumericStyleProp, isObject, isOn, isPlainObject, isPromise, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, makeMap, normalizeClass, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n", "import { EMPTY_OBJ, isArray, isMap, isIntegerKey, isSymbol, extend, hasOwn, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            oldValue = toRaw(oldValue);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst shallowReadonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, true)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        if (self._dirty) {\r\n            self._value = this.effect();\r\n            self._dirty = false;\r\n        }\r\n        track(self, \"get\" /* GET */, 'value');\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nexport { ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n", "import { nextTick } from '../nextTick'\nimport { magic } from '../magics'\n\nmagic('nextTick', () => nextTick)\n", "import { dispatch } from '../utils/dispatch'\nimport { magic } from '../magics'\n\nmagic('dispatch', el => dispatch.bind(dispatch, el))\n", "import { magic } from '../magics'\n\nmagic('watch', (el, { evaluateLater, effect }) => (key, callback) => {\n    let evaluate = evaluateLater(key)\n\n    let firstTime = true\n\n    let oldValue\n\n    let effectReference = effect(() => evaluate(value => {\n        // JSON.stringify touches every single property at any level enabling deep watching\n        JSON.stringify(value)\n\n        if (! firstTime) {\n            // We have to queue this watcher as a microtask so that\n            // the watcher doesn't pick up its own dependencies.\n            queueMicrotask(() => {\n                callback(value, oldValue)\n\n                oldValue = value\n            })\n        } else {\n            oldValue = value\n        }\n\n        firstTime = false\n    }))\n\n    // We want to remove this effect from the list of effects\n    // stored on an element. Livewire uses that list to\n    // \"re-run\" Alpine effects after a page load. A \"watcher\"\n    // shuldn't be re-run like that. It will cause infinite loops.\n    el._x_effects.delete(effectReference)\n})\n", "import { getStores } from '../store'\nimport { magic } from '../magics'\n\nmagic('store', getStores)\n", "import { scope } from '../scope'\nimport { magic } from '../magics'\n\nmagic('data', el => scope(el))\n", "import { closestRoot } from \"../lifecycle\";\nimport { magic } from \"../magics\";\n\nmagic('root', el => closestRoot(el))\n", "import { closestRoot } from '../lifecycle'\nimport { mergeProxies } from '../scope'\nimport { magic } from '../magics'\n\nmagic('refs', el => {\n    if (el._x_refs_proxy) return el._x_refs_proxy\n\n    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el))\n\n    return el._x_refs_proxy\n})\n\nfunction getArrayOfRefObject(el) {\n    let refObjects = []\n\n    let currentEl = el\n\n    while (currentEl) {\n        if (currentEl._x_refs) refObjects.push(currentEl._x_refs)\n\n        currentEl = currentEl.parentNode\n    }\n\n    return refObjects\n}\n", "import { findClosest } from './lifecycle'\n\nlet globalIdMemo = {}\n\nexport function findAndIncrementId(name) {\n    if (! globalIdMemo[name]) globalIdMemo[name] = 0\n\n    return ++globalIdMemo[name]\n}\n\nexport function closestIdRoot(el, name) {\n    return findClosest(el, element => {\n        if (element._x_ids && element._x_ids[name]) return true\n    })\n}\n\nexport function setIdRoot(el, name) {\n    if (! el._x_ids) el._x_ids = {}\n    if (! el._x_ids[name]) el._x_ids[name] = findAndIncrementId(name) \n}\n", "import { magic } from '../magics'\nimport { closestIdRoot, findAndIncrementId } from '../ids'\n\nmagic('id', el => (name, key = null) => {\n    let root = closestIdRoot(el, name)\n\n    let id = root\n        ? root._x_ids[name]\n        : findAndIncrementId(name)\n\n    return key\n        ? `${name}-${id}-${key}`\n        : `${name}-${id}`\n})\n", "import { magic } from \"../magics\";\n\nmagic('el', el => el)\n", "import { warn } from '../utils/warn'\nimport { magic } from '../magics'\n\nimport './$nextTick'\nimport './$dispatch'\nimport './$watch'\nimport './$store'\nimport './$data'\nimport './$root'\nimport './$refs'\nimport './$id'\nimport './$el'\n\n// Register warnings for people using plugin syntaxes and not loading the plugin itself:\nwarnMissingPluginMagic('Focus', 'focus', 'focus')\nwarnMissingPluginMagic('Persist', 'persist', 'persist')\n\nfunction warnMissingPluginMagic(name, magicName, slug) {\n    magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el))\n}\n", "import { directive } from '../directives'\n\ndirective('modelable', (el, { expression }, { effect, evaluateLater }) => {\n    let func = evaluateLater(expression)\n    let innerGet = () => { let result; func(i => result = i); return result; }\n    let evaluateInnerSet = evaluateLater(`${expression} = __placeholder`)\n    let innerSet = val => evaluateInnerSet(() => {}, { scope: { '__placeholder': val }})\n\n    let initialValue = innerGet()\n\n    innerSet(initialValue)\n\n    queueMicrotask(() => {\n        if (! el._x_model) return\n\n        // Remove native event listeners as these are now bound with x-modelable.\n        // The reason for this is that it's often useful to wrap <input> elements\n        // in x-modelable/model, but the input events from the native input\n        // override any functionality added by x-modelable causing confusion.\n        el._x_removeModelListeners['default']()\n    \n        let outerGet = el._x_model.get\n        let outerSet = el._x_model.set\n    \n        effect(() => innerSet(outerGet()))\n        effect(() => outerSet(innerGet()))\n    })\n})\n", "import { directive } from \"../directives\"\nimport { addInitSelector, initTree } from \"../lifecycle\"\nimport { mutateDom } from \"../mutation\"\nimport { addScopeToNode } from \"../scope\"\nimport { warn } from \"../utils/warn\"\n\ndirective('teleport', (el, { expression }, { cleanup }) => {\n    if (el.tagName.toLowerCase() !== 'template') warn('x-teleport can only be used on a <template> tag', el)\n\n    let target = document.querySelector(expression)\n\n    if (! target) warn(`Cannot find x-teleport element for selector: \"${expression}\"`)\n\n    let clone = el.content.cloneNode(true).firstElementChild\n\n    // Add reference to element on <template x-teleport, and visa versa.\n    el._x_teleport = clone\n    clone._x_teleportBack = el\n\n    // Forward event listeners:\n    if (el._x_forwardEvents) {\n        el._x_forwardEvents.forEach(eventName => {\n            clone.addEventListener(eventName, e => {\n                e.stopPropagation()\n\n                el.dispatchEvent(new e.constructor(e.type, e))\n            })\n        })\n    }\n\n    addScopeToNode(clone, {}, el)\n\n    mutateDom(() => {\n        target.appendChild(clone)\n\n        initTree(clone)\n\n        clone._x_ignore = true\n    })\n\n    cleanup(() => clone.remove())\n})\n", "import { directive } from \"../directives\"\n\nlet handler = () => {}\n\nhandler.inline = (el, { modifiers }, { cleanup }) => {\n    modifiers.includes('self')\n        ? el._x_ignoreSelf = true\n        : el._x_ignore = true\n\n    cleanup(() => {\n        modifiers.includes('self')\n            ? delete el._x_ignoreSelf\n            : delete el._x_ignore\n    })\n}\n\ndirective('ignore', handler)\n", "import { directive } from '../directives'\nimport { evaluateLater } from '../evaluator'\n\ndirective('effect', (el, { expression }, { effect }) => effect(evaluateLater(el, expression)))\n", "import { debounce } from './debounce'\nimport { throttle } from './throttle'\n\nexport default function on (el, event, modifiers, callback) {\n    let listenerTarget = el\n\n    let handler = e => callback(e)\n\n    let options = {}\n\n    // This little helper allows us to add functionality to the listener's\n    // handler more flexibly in a \"middleware\" style.\n    let wrapHandler = (callback, wrapper) => (e) => wrapper(callback, e)\n\n    if (modifiers.includes(\"dot\")) event = dotSyntax(event)\n    if (modifiers.includes('camel')) event = camelCase(event)\n    if (modifiers.includes('passive')) options.passive = true\n    if (modifiers.includes('capture')) options.capture = true\n    if (modifiers.includes('window')) listenerTarget = window\n    if (modifiers.includes('document')) listenerTarget = document\n    if (modifiers.includes('prevent')) handler = wrapHandler(handler, (next, e) => { e.preventDefault(); next(e) })\n    if (modifiers.includes('stop')) handler = wrapHandler(handler, (next, e) => { e.stopPropagation(); next(e) })\n    if (modifiers.includes('self')) handler = wrapHandler(handler, (next, e) => { e.target === el && next(e) })\n\n    if (modifiers.includes('away') || modifiers.includes('outside')) {\n        listenerTarget = document\n\n        handler = wrapHandler(handler, (next, e) => {\n            if (el.contains(e.target)) return\n\n            if (e.target.isConnected === false) return\n\n            if (el.offsetWidth < 1 && el.offsetHeight < 1) return\n\n            // Additional check for special implementations like x-collapse\n            // where the element doesn't have display: none\n            if (el._x_isShown === false) return\n\n            next(e)\n        })\n    }\n\n    if (modifiers.includes('once')) {\n        handler = wrapHandler(handler, (next, e) => {\n            next(e)\n\n            listenerTarget.removeEventListener(event, handler, options)\n        })\n    }\n\n    // Handle :keydown and :keyup listeners.\n    handler = wrapHandler(handler, (next, e) => {\n        if (isKeyEvent(event)) {\n            if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n                return\n            }\n        }\n\n        next(e)\n    })\n\n    if (modifiers.includes('debounce')) {\n        let nextModifier = modifiers[modifiers.indexOf('debounce')+1] || 'invalid-wait'\n        let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250\n\n        handler = debounce(handler, wait)\n    }\n\n    if (modifiers.includes('throttle')) {\n        let nextModifier = modifiers[modifiers.indexOf('throttle')+1] || 'invalid-wait'\n        let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250\n\n        handler = throttle(handler, wait)\n    }\n\n    listenerTarget.addEventListener(event, handler, options)\n\n    return () => {\n        listenerTarget.removeEventListener(event, handler, options)\n    }\n}\n\nfunction dotSyntax(subject) {\n    return subject.replace(/-/g, \".\")\n}\n\nfunction camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase())\n}\n\nfunction isNumeric(subject){\n    return ! Array.isArray(subject) && ! isNaN(subject)\n}\n\nfunction kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase()\n}\n\nfunction isKeyEvent(event) {\n    return ['keydown', 'keyup'].includes(event)\n}\n\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n    let keyModifiers = modifiers.filter(i => {\n        return ! ['window', 'document', 'prevent', 'stop', 'once'].includes(i)\n    })\n\n    if (keyModifiers.includes('debounce')) {\n        let debounceIndex = keyModifiers.indexOf('debounce')\n        keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex+1] || 'invalid-wait').split('ms')[0]) ? 2 : 1)\n    }\n\n    // If no modifier is specified, we'll call it a press.\n    if (keyModifiers.length === 0) return false\n\n    // If one is passed, AND it matches the key pressed, we'll call it a press.\n    if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0])) return false\n\n    // The user is listening for key combinations.\n    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super']\n    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier))\n\n    keyModifiers = keyModifiers.filter(i => ! selectedSystemKeyModifiers.includes(i))\n\n    if (selectedSystemKeyModifiers.length > 0) {\n        const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n            // Alias \"cmd\" and \"super\" to \"meta\"\n            if (modifier === 'cmd' || modifier === 'super') modifier = 'meta'\n\n            return e[`${modifier}Key`]\n        })\n\n        // If all the modifiers selected are pressed, ...\n        if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n            // AND the remaining key is pressed as well. It's a press.\n            if (keyToModifiers(e.key).includes(keyModifiers[0])) return false\n        }\n    }\n\n    // We'll call it NOT a valid keypress.\n    return true\n}\n\nfunction keyToModifiers(key) {\n    if (! key) return []\n\n    key = kebabCase(key)\n\n    let modifierToKeyMap = {\n        'ctrl': 'control',\n        'slash': '/',\n        'space': '-',\n        'spacebar': '-',\n        'cmd': 'meta',\n        'esc': 'escape',\n        'up': 'arrow-up',\n        'down': 'arrow-down',\n        'left': 'arrow-left',\n        'right': 'arrow-right',\n        'period': '.',\n        'equal': '=',\n    }\n\n    modifierToKeyMap[key] = key\n\n    return Object.keys(modifierToKeyMap).map(modifier => {\n        if (modifierToKeyMap[modifier] === key) return modifier\n    }).filter(modifier => modifier)\n}\n", "import { evaluateLater } from '../evaluator'\nimport { directive } from '../directives'\nimport { mutateDom } from '../mutation'\nimport bind from '../utils/bind'\nimport on from '../utils/on'\n\ndirective('model', (el, { modifiers, expression }, { effect, cleanup }) => {\n    let evaluate = evaluateLater(el, expression)\n    let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`\n    let evaluateAssignment = evaluateLater(el, assignmentExpression)\n\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = (el.tagName.toLowerCase() === 'select')\n        || ['checkbox', 'radio'].includes(el.type)\n        || modifiers.includes('lazy')\n            ? 'change' : 'input'\n\n    let assigmentFunction = generateAssignmentFunction(el, modifiers, expression)\n\n    let removeListener = on(el, event, modifiers, (e) => {\n        evaluateAssignment(() => {}, { scope: {\n            '$event': e,\n            rightSideOfExpression: assigmentFunction\n        }})\n    })\n\n    // Register the listener removal callback on the element, so that\n    // in addition to the cleanup function, x-modelable may call it.\n    // Also, make this a keyed object if we decide to reintroduce\n    // \"named modelables\" some time in a future Alpine version.\n    if (! el._x_removeModelListeners) el._x_removeModelListeners = {}\n    el._x_removeModelListeners['default'] = removeListener\n\n    cleanup(() => el._x_removeModelListeners['default']())\n\n    // Allow programmatic overiding of x-model.\n    let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`)\n    el._x_model = {\n        get() {\n            let result\n            evaluate(value => result = value)\n            return result\n        },\n        set(value) {\n            evaluateSetModel(() => {}, { scope: { '__placeholder': value }})\n        },\n    }\n\n    el._x_forceModelUpdate = () => {\n        evaluate(value => {\n            // If nested model key is undefined, set the default value to empty string.\n            if (value === undefined && expression.match(/\\./)) value = ''\n\n            // @todo: This is nasty\n            window.fromModel = true\n            mutateDom(() => bind(el, 'value', value))\n            delete window.fromModel\n        })\n    }\n\n    effect(() => {\n        // Don't modify the value of the input if it's focused.\n        if (modifiers.includes('unintrusive') && document.activeElement.isSameNode(el)) return\n\n        el._x_forceModelUpdate()\n    })\n})\n\nfunction generateAssignmentFunction(el, modifiers, expression) {\n    if (el.type === 'radio') {\n        // Radio buttons only work properly when they share a name attribute.\n        // People might assume we take care of that for them, because\n        // they already set a shared \"x-model\" attribute.\n        mutateDom(() => {\n            if (! el.hasAttribute('name')) el.setAttribute('name', expression)\n        })\n    }\n\n    return (event, currentValue) => {\n        return mutateDom(() => {\n            // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n            // Safari autofill triggers event as CustomEvent and assigns value to target\n            // so we return event.target.value instead of event.detail\n            if (event instanceof CustomEvent && event.detail !== undefined) {\n                return event.detail || event.target.value\n            } else if (el.type === 'checkbox') {\n                // If the data we are binding to is an array, toggle its value inside the array.\n                if (Array.isArray(currentValue)) {\n                    let newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value\n\n                    return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => ! checkedAttrLooseCompare(el, newValue))\n                } else {\n                    return event.target.checked\n                }\n            } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n                return modifiers.includes('number')\n                    ? Array.from(event.target.selectedOptions).map(option => {\n                        let rawValue = option.value || option.text\n                        return safeParseNumber(rawValue)\n                    })\n                    : Array.from(event.target.selectedOptions).map(option => {\n                        return option.value || option.text\n                    })\n            } else {\n                let rawValue = event.target.value\n                return modifiers.includes('number')\n                    ? safeParseNumber(rawValue)\n                    : (modifiers.includes('trim') ? rawValue.trim() : rawValue)\n            }\n        })\n    }\n}\n\nfunction safeParseNumber(rawValue) {\n    let number = rawValue ? parseFloat(rawValue) : null\n\n    return isNumeric(number) ? number : rawValue\n}\n\nfunction checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB\n}\n\nfunction isNumeric(subject){\n    return ! Array.isArray(subject) && ! isNaN(subject)\n}\n", "import { directive, prefix } from '../directives'\nimport { mutateDom } from '../mutation'\n\ndirective('cloak', el => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix('cloak')))))\n", "import { directive, prefix } from \"../directives\";\nimport { addInitSelector } from \"../lifecycle\";\nimport { skipDuringClone } from \"../clone\";\n\naddInitSelector(() => `[${prefix('init')}]`)\n\ndirective('init', skipDuringClone((el, { expression }, { evaluate }) => {\n  if (typeof expression === 'string') {\n    return !! expression.trim() && evaluate(expression, {}, false)\n  }\n\n  return evaluate(expression, {}, false)\n}))\n", "import { directive } from '../directives'\nimport { mutateDom } from '../mutation'\n\ndirective('text', (el, { expression }, { effect, evaluateLater }) => {\n    let evaluate = evaluateLater(expression)\n\n    effect(() => {\n        evaluate(value => {\n            mutateDom(() => {\n                el.textContent = value\n            })\n        })\n    })\n})\n", "import { directive } from '../directives'\nimport { initTree } from '../lifecycle'\nimport { mutateDom } from '../mutation'\n\ndirective('html', (el, { expression }, { effect, evaluateLater }) => {\n    let evaluate = evaluateLater(expression)\n\n    effect(() => {\n        evaluate(value => {\n            mutateDom(() => {\n                el.innerHTML = value\n\n                el._x_ignoreSelf = true\n                initTree(el)\n                delete el._x_ignoreSelf\n            })\n        })\n    })\n})\n", "import { directive, into, mapAttributes, prefix, startingWith } from '../directives'\nimport { evaluateLater } from '../evaluator'\nimport { mutateDom } from '../mutation'\nimport bind from '../utils/bind'\nimport { applyBindingsObject, injectBindingProviders } from '../binds'\n\nmapAttributes(startingWith(':', into(prefix('bind:'))))\n\ndirective('bind', (el, { value, modifiers, expression, original }, { effect }) => {\n    if (! value) {\n        let bindingProviders = {}\n        injectBindingProviders(bindingProviders)\n\n        let getBindings = evaluateLater(el, expression)\n\n        getBindings(bindings => {\n            applyBindingsObject(el, bindings, original)\n        }, { scope: bindingProviders } )\n\n        return\n    }\n\n    if (value === 'key') return storeKeyForXFor(el, expression)\n\n    let evaluate = evaluateLater(el, expression)\n\n    effect(() => evaluate(result => {\n        // If nested object key is undefined, set the default value to empty string.\n        if (result === undefined && typeof expression === 'string' && expression.match(/\\./)) {\n            result = ''\n        }\n\n        mutateDom(() => bind(el, value, result, modifiers))\n    }))\n})\n\n\nfunction storeKeyForXFor(el, expression) {\n    el._x_keyExpression = expression\n}\n", "import { directive, prefix } from '../directives'\nimport { initInterceptors } from '../interceptor'\nimport { injectDataProviders } from '../datas'\nimport { addRootSelector } from '../lifecycle'\nimport { skipDuringClone } from '../clone'\nimport { addScopeToNode } from '../scope'\nimport { injectMagics, magic } from '../magics'\nimport { reactive } from '../reactivity'\nimport { evaluate } from '../evaluator'\n\naddRootSelector(() => `[${prefix('data')}]`)\n\ndirective('data', skipDuringClone((el, { expression }, { cleanup }) => {\n    expression = expression === '' ? '{}' : expression\n\n    let magicContext = {}\n    injectMagics(magicContext, el)\n\n    let dataProviderContext = {}\n    injectDataProviders(dataProviderContext, magicContext)\n\n    let data = evaluate(el, expression, { scope: dataProviderContext })\n\n    if (data === undefined) data = {}\n\n    injectMagics(data, el)\n\n    let reactiveData = reactive(data)\n\n    initInterceptors(reactiveData)\n\n    let undo = addScopeToNode(el, reactiveData)\n\n    reactiveData['init'] && evaluate(el, reactiveData['init'])\n\n    cleanup(() => {\n        reactiveData['destroy'] && evaluate(el, reactiveData['destroy'])\n\n        undo()\n    })\n}))\n", "import { evaluateLater } from '../evaluator'\nimport { directive } from '../directives'\nimport { mutateDom } from '../mutation'\nimport { once } from '../utils/once'\n\ndirective('show', (el, { modifiers, expression }, { effect }) => {\n    let evaluate = evaluateLater(el, expression)\n\n    // We're going to set this function on the element directly so that\n    // other plugins like \"Collapse\" can overwrite them with their own logic.\n    if (! el._x_doHide) el._x_doHide = () => {\n        mutateDom(() => {\n            el.style.setProperty('display', 'none', modifiers.includes('important') ? 'important' : undefined)\n        })\n    }\n\n    if (! el._x_doShow) el._x_doShow = () => {\n        mutateDom(() => {\n            if (el.style.length === 1 && el.style.display === 'none') {\n                el.removeAttribute('style')\n            } else {\n                el.style.removeProperty('display')\n            }\n        })\n    }\n\n    let hide = () => {\n        el._x_doHide()\n        el._x_isShown = false\n    }\n\n    let show = () => {\n        el._x_doShow()\n        el._x_isShown = true\n    }\n\n    // We are wrapping this function in a setTimeout here to prevent\n    // a race condition from happening where elements that have a\n    // @click.away always view themselves as shown on the page.\n    let clickAwayCompatibleShow = () => setTimeout(show)\n\n    let toggle = once(\n        value => value ? show() : hide(),\n        value => {\n            if (typeof el._x_toggleAndCascadeWithTransitions === 'function') {\n                el._x_toggleAndCascadeWithTransitions(el, value, show, hide)\n            } else {\n                value ? clickAwayCompatibleShow() : hide()\n            }\n        }\n    )\n\n    let oldValue\n    let firstTime = true\n\n    effect(() => evaluate(value => {\n        // Let's make sure we only call this effect if the value changed.\n        // This prevents \"blip\" transitions. (1 tick out, then in)\n        if (! firstTime && value === oldValue) return\n\n        if (modifiers.includes('immediate')) value ? clickAwayCompatibleShow() : hide()\n\n        toggle(value)\n\n        oldValue = value\n        firstTime = false\n    }))\n})\n", "import { addScopeToNode, refreshScope } from '../scope'\nimport { evaluateLater } from '../evaluator'\nimport { directive } from '../directives'\nimport { reactive } from '../reactivity'\nimport { initTree } from '../lifecycle'\nimport { mutateDom } from '../mutation'\nimport { flushJobs } from '../scheduler'\nimport { warn } from '../utils/warn'\nimport { dequeueJob } from '../scheduler'\n\ndirective('for', (el, { expression }, { effect, cleanup }) => {\n    let iteratorNames = parseForExpression(expression)\n\n    let evaluateItems = evaluateLater(el, iteratorNames.items)\n    let evaluateKey = evaluateLater(el,\n        // the x-bind:key expression is stored for our use instead of evaluated.\n        el._x_keyExpression || 'index'\n    )\n\n    el._x_prevKeys = []\n    el._x_lookup = {}\n\n    effect(() => loop(el, iteratorNames, evaluateItems, evaluateKey))\n\n    cleanup(() => {\n        Object.values(el._x_lookup).forEach(el => el.remove())\n\n        delete el._x_prevKeys\n        delete el._x_lookup\n    })\n})\n\nlet shouldFastRender = true\n\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n    let isObject = i => typeof i === 'object' && ! Array.isArray(i)\n    let templateEl = el\n\n    evaluateItems(items => {\n        // Prepare yourself. There's a lot going on here. Take heart,\n        // every bit of complexity in this function was added for\n        // the purpose of making Alpine fast with large datas.\n\n        // Support number literals. Ex: x-for=\"i in 100\"\n        if (isNumeric(items) && items >= 0) {\n            items = Array.from(Array(items).keys(), i => i + 1)\n        }\n\n        if (items === undefined) items = []\n\n        let lookup = el._x_lookup\n        let prevKeys = el._x_prevKeys\n        let scopes = []\n        let keys = []\n\n        // In order to preserve DOM elements (move instead of replace)\n        // we need to generate all the keys for every iteration up\n        // front. These will be our source of truth for diffing.\n        if (isObject(items)) {\n            items = Object.entries(items).map(([key, value]) => {\n                let scope = getIterationScopeVariables(iteratorNames, value, key, items)\n\n                evaluateKey(value => keys.push(value), { scope: { index: key, ...scope} })\n\n                scopes.push(scope)\n            })\n        } else {\n            for (let i = 0; i < items.length; i++) {\n                let scope = getIterationScopeVariables(iteratorNames, items[i], i, items)\n\n                evaluateKey(value => keys.push(value), { scope: { index: i, ...scope} })\n\n                scopes.push(scope)\n            }\n        }\n\n        // Rather than making DOM manipulations inside one large loop, we'll\n        // instead track which mutations need to be made in the following\n        // arrays. After we're finished, we can batch them at the end.\n        let adds = []\n        let moves = []\n        let removes = []\n        let sames = []\n\n        // First, we track elements that will need to be removed.\n        for (let i = 0; i < prevKeys.length; i++) {\n            let key = prevKeys[i]\n\n            if (keys.indexOf(key) === -1) removes.push(key)\n        }\n\n        // Notice we're mutating prevKeys as we go. This makes it\n        // so that we can efficiently make incremental comparisons.\n        prevKeys = prevKeys.filter(key => ! removes.includes(key))\n\n        let lastKey = 'template'\n\n        // This is the important part of the diffing algo. Identifying\n        // which keys (future DOM elements) are new, which ones have\n        // or haven't moved (noting where they moved to / from).\n        for (let i = 0; i < keys.length; i++) {\n            let key = keys[i]\n\n            let prevIndex = prevKeys.indexOf(key)\n\n            if (prevIndex === -1) {\n                // New key found.\n                prevKeys.splice(i, 0, key)\n\n                adds.push([lastKey, i])\n            } else if (prevIndex !== i) {\n                // A key has moved.\n                let keyInSpot = prevKeys.splice(i, 1)[0]\n                let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0]\n\n                prevKeys.splice(i, 0, keyForSpot)\n                prevKeys.splice(prevIndex, 0, keyInSpot)\n\n                moves.push([keyInSpot, keyForSpot])\n            } else {\n                // This key hasn't moved, but we'll still keep track\n                // so that we can refresh it later on.\n                sames.push(key)\n            }\n\n            lastKey = key\n        }\n\n        // Now that we've done the diffing work, we can apply the mutations\n        // in batches for both separating types work and optimizing\n        // for browser performance.\n\n        // We'll remove all the nodes that need to be removed,\n        // letting the mutation observer pick them up and\n        // clean up any side effects they had.\n        for (let i = 0; i < removes.length; i++) {\n            let key = removes[i]\n\n            // Remove any queued effects that might run after the DOM node has been removed.\n            if (!! lookup[key]._x_effects) {\n                lookup[key]._x_effects.forEach(dequeueJob)\n            }\n            \n            lookup[key].remove()\n\n            lookup[key] = null\n            delete lookup[key]\n        }\n\n        // Here we'll move elements around, skipping\n        // mutation observer triggers by using \"mutateDom\".\n        for (let i = 0; i < moves.length; i++) {\n            let [keyInSpot, keyForSpot] = moves[i]\n\n            let elInSpot = lookup[keyInSpot]\n            let elForSpot = lookup[keyForSpot]\n\n            let marker = document.createElement('div')\n\n            mutateDom(() => {\n                elForSpot.after(marker)\n                elInSpot.after(elForSpot)\n                elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl)\n                marker.before(elInSpot)\n                elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl)\n                marker.remove()\n            })\n\n            refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)])\n        }\n\n        // We can now create and add new elements.\n        for (let i = 0; i < adds.length; i++) {\n            let [lastKey, index] = adds[i]\n\n            let lastEl = (lastKey === 'template') ? templateEl : lookup[lastKey]\n            // If the element is a x-if template evaluated to true,\n            // point lastEl to the if-generated node\n            if (lastEl._x_currentIfEl) lastEl = lastEl._x_currentIfEl\n\n            let scope = scopes[index]\n            let key = keys[index]\n\n            let clone = document.importNode(templateEl.content, true).firstElementChild\n\n            addScopeToNode(clone, reactive(scope), templateEl)\n\n            mutateDom(() => {\n                lastEl.after(clone)\n\n                initTree(clone)\n            })\n\n            if (typeof key === 'object') {\n                warn('x-for key cannot be an object, it must be a string or an integer', templateEl)\n            }\n\n            lookup[key] = clone\n        }\n\n        // If an element hasn't changed, we still want to \"refresh\" the\n        // data it depends on in case the data has changed in an\n        // \"unobservable\" way.\n        for (let i = 0; i < sames.length; i++) {\n            refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])])\n        }\n\n        // Now we'll log the keys (and the order they're in) for comparing\n        // against next time.\n        templateEl._x_prevKeys = keys\n    })\n}\n\n// This was taken from VueJS 2.* core. Thanks Vue!\nfunction parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\n    let stripParensRE = /^\\s*\\(|\\)\\s*$/g\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n    let inMatch = expression.match(forAliasRE)\n\n    if (! inMatch) return\n\n    let res = {}\n    res.items = inMatch[2].trim()\n    let item = inMatch[1].replace(stripParensRE, '').trim()\n    let iteratorMatch = item.match(forIteratorRE)\n\n    if (iteratorMatch) {\n        res.item = item.replace(forIteratorRE, '').trim()\n        res.index = iteratorMatch[1].trim()\n\n        if (iteratorMatch[2]) {\n            res.collection = iteratorMatch[2].trim()\n        }\n    } else {\n        res.item = item\n    }\n\n    return res\n}\n\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = {}\n\n    // Support array destructuring ([foo, bar]).\n    if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n        let names = iteratorNames.item.replace('[', '').replace(']', '').split(',').map(i => i.trim())\n\n        names.forEach((name, i) => {\n            scopeVariables[name] = item[i]\n        })\n    // Support object destructuring ({ foo: 'oof', bar: 'rab' }).\n    } else if (/^\\{.*\\}$/.test(iteratorNames.item) && ! Array.isArray(item) && typeof item === 'object') {\n        let names = iteratorNames.item.replace('{', '').replace('}', '').split(',').map(i => i.trim())\n\n        names.forEach(name => {\n            scopeVariables[name] = item[name]\n        })\n    } else {\n        scopeVariables[iteratorNames.item] = item\n    }\n\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index\n\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items\n\n    return scopeVariables\n}\n\nfunction isNumeric(subject){\n    return ! Array.isArray(subject) && ! isNaN(subject)\n}\n", "import { closestRoot } from '../lifecycle'\nimport { directive } from '../directives'\n\nfunction handler () {}\n\nhandler.inline = (el, { expression }, { cleanup }) => {\n    let root = closestRoot(el)\n\n    if (! root._x_refs) root._x_refs = {}\n\n    root._x_refs[expression] = el\n\n    cleanup(() => delete root._x_refs[expression])\n}\n\ndirective('ref', handler)\n", "import { evaluateLater } from '../evaluator'\nimport { addScopeToNode } from '../scope'\nimport { directive } from '../directives'\nimport { initTree } from '../lifecycle'\nimport { mutateDom } from '../mutation'\nimport { walk } from \"../utils/walk\"\nimport { dequeueJob } from '../scheduler'\n\ndirective('if', (el, { expression }, { effect, cleanup }) => {\n    let evaluate = evaluateLater(el, expression)\n\n    let show = () => {\n        if (el._x_currentIfEl) return el._x_currentIfEl\n\n        let clone = el.content.cloneNode(true).firstElementChild\n\n        addScopeToNode(clone, {}, el)\n\n        mutateDom(() => {\n            el.after(clone)\n\n            initTree(clone)\n        })\n\n        el._x_currentIfEl = clone\n\n        el._x_undoIf = () => {\n            walk(clone, (node) => {\n                if (!!node._x_effects) {\n                    node._x_effects.forEach(dequeueJob)\n                }\n            })\n            \n            clone.remove();\n\n            delete el._x_currentIfEl\n        }\n\n        return clone\n    }\n\n    let hide = () => {\n        if (! el._x_undoIf) return\n\n        el._x_undoIf()\n\n        delete el._x_undoIf\n    }\n\n    effect(() => evaluate(value => {\n        value ? show() : hide()\n    }))\n\n    cleanup(() => el._x_undoIf && el._x_undoIf())\n})\n", "import { directive } from \"../directives\"\nimport { setIdRoot } from '../ids'\n\ndirective('id', (el, { expression }, { evaluate }) => {\n    let names = evaluate(expression)\n    \n    names.forEach(name => setIdRoot(el, name))\n})\n", "import { directive, into, mapAttributes, prefix, startingWith } from '../directives'\nimport { evaluateLater } from '../evaluator'\nimport { skipDuringClone } from '../clone'\nimport on from '../utils/on'\n\nmapAttributes(startingWith('@', into(prefix('on:'))))\n\ndirective('on', skipDuringClone((el, { value, modifiers, expression }, { cleanup }) => {\n    let evaluate = expression ? evaluateLater(el, expression) : () => {}\n   \n    // Forward event listeners on portals.\n    if (el.tagName.toLowerCase() === 'template') {\n        if (! el._x_forwardEvents) el._x_forwardEvents = []\n        if (! el._x_forwardEvents.includes(value)) el._x_forwardEvents.push(value)\n    }\n\n    let removeListener = on(el, value, modifiers, e => {\n        evaluate(() => {}, { scope: { '$event': e }, params: [e] })\n    })\n\n    cleanup(() => removeListener())\n}))\n", "import { directive } from '../directives'\nimport { warn } from '../utils/warn'\n\nimport './x-transition'\nimport './x-modelable'\nimport './x-teleport'\nimport './x-ignore'\nimport './x-effect'\nimport './x-model'\nimport './x-cloak'\nimport './x-init'\nimport './x-text'\nimport './x-html'\nimport './x-bind'\nimport './x-data'\nimport './x-show'\nimport './x-for'\nimport './x-ref'\nimport './x-if'\nimport './x-id'\nimport './x-on'\n\n// Register warnings for people using plugin syntaxes and not loading the plugin itself:\nwarnMissingPluginDirective('Collapse', 'collapse', 'collapse')\nwarnMissingPluginDirective('Intersect', 'intersect', 'intersect')\nwarnMissingPluginDirective('Focus', 'trap', 'focus')\nwarnMissingPluginDirective('Mask', 'mask', 'mask')\n\nfunction warnMissingPluginDirective(name, directiveName, slug) {\n    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el))\n}\n", "/**\n *           _\n *     /\\   | |     (_)            (_)\n *    /  \\  | |_ __  _ _ __   ___   _ ___\n *   / /\\ \\ | | '_ \\| | '_ \\ / _ \\ | / __|\n *  / ____ \\| | |_) | | | | |  __/_| \\__ \\\n * /_/    \\_\\_| .__/|_|_| |_|\\___(_) |___/\n *            | |                 _/ |\n *            |_|                |__/\n *\n * Let's build Alpine together. It's easier than you think.\n * For starters, we'll import Alpine's core. This is the\n * object that will expose all of Alpine's public API.\n */\nimport Alpine from './alpine'\n\n/**\n * _______________________________________________________\n * The Evaluator\n * -------------------------------------------------------\n *\n * Now we're ready to bootstrap Alpine's evaluation system.\n * It's the function that converts raw JavaScript string\n * expressions like @click=\"toggle()\", into actual JS.\n */\nimport { normalEvaluator } from './evaluator'\n\nAlpine.setEvaluator(normalEvaluator)\n\n/**\n * _______________________________________________________\n * The Reactivity Engine\n * -------------------------------------------------------\n *\n * This is the reactivity core of Alpine. It's the part of\n * Alpine that triggers an element with x-text=\"message\"\n * to update its inner text when \"message\" is changed.\n */\nimport { reactive, effect, stop, toRaw } from '@vue/reactivity'\n\nAlpine.setReactivityEngine({ reactive, effect, release: stop, raw: toRaw })\n\n/**\n * _______________________________________________________\n * The Magics\n * -------------------------------------------------------\n *\n * Yeah, we're calling them magics here like they're nouns.\n * These are the properties that are magically available\n * to all the Alpine expressions, within your web app.\n */\nimport './magics/index'\n\n/**\n * _______________________________________________________\n * The Directives\n * -------------------------------------------------------\n *\n * Now that the core is all set up, we can register Alpine\n * directives like x-text or x-on that form the basis of\n * how Alpine adds behavior to an app's static markup.\n */\nimport './directives/index'\n\n/**\n * _______________________________________________________\n * The Alpine Global\n * -------------------------------------------------------\n *\n * Now that we have set everything up internally, anything\n * Alpine-related that will need to be accessed on-going\n * will be made available through the \"Alpine\" global.\n */\nexport default Alpine\n", "import Alpine from './../src/index'\n\nwindow.Alpine = Alpine\n\nqueueMicrotask(() => {\n    Alpine.start()\n})\n"],
  "mappings": "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",
  "names": []
}
